`ROWID`를 **찾아가는 것이 고비용인 이유**는 데이터베이스의 **저장 방식과 접근 방식** 때문입니다. 상황에 따라 다르지만, 일반적인 이유를 아래에 설명드릴게요:

### ✅ 1. **ROWID를 직접 찾는 방식은 Random I/O를 유발할 수 있음**
- `ROWID`는 Oracle 같은 DB에서 **물리적인 데이터 위치**를 가리킵니다.
- 단일 `ROWID`를 찾기 위해 **디스크의 특정 블록**으로 직접 접근해야 하며, 이 과정이 **랜덤 액세스(Random I/O)**를 유발합니다.
- 랜덤 I/O는 연속적인 순차 I/O보다 훨씬 **느리고 비용이 큽니다.**

---

### ✅ 2. **Index Scan + ROWID 접근 구조**
- 일반적으로 인덱스를 통해 조건에 맞는 `ROWID`를 찾고,
- 해당 `ROWID`로 테이블의 실제 데이터를 찾아가는 **두 단계**로 동작합니다.
- 이때 **인덱스는 메모리 캐시에 있을 수 있지만**, 실제 테이블의 ROWID 위치는 디스크 I/O가 필요한 경우가 많아 **성능 저하**가 발생할 수 있습니다.

---

### ✅ 3. **ROWID 기반 Join, Nested Loop 등의 연산에서 비효율**
- `Nested Loop Join` 같은 경우, 내부 루프에서 계속 `ROWID`를 참조해 테이블에 접근하면
- **매번 랜덤 디스크 I/O**가 발생해 성능이 급격히 떨어질 수 있어요.

---

### ✅ 결론
- `ROWID` 자체는 빠르게 특정 레코드를 찾을 수 있는 좋은 도구지만, **접근 패턴에 따라 랜덤 I/O가 많아질 수 있어서 고비용**으로 간주되기도 합니다.
- 그래서 쿼리 튜닝 시에는 `ROWID` 접근보다 **Index Only Scan** 또는 **Hash Join**, **Sort Merge Join** 등을 활용하는 게 효율적인 경우도 많습니다.

---
