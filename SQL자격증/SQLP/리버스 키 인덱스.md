리버스 키 인덱스(Reverse Key Index)는 **인덱스 컬럼의 값을 거꾸로(reverse) 저장하는 인덱스 방식**입니다. 오라클에서 대량의 데이터가 연속적으로 증가(또는 감소)하는 키 값을 가질 때 발생하는 **"인덱스 블록의 핫스팟 문제(hot spot)"**를 해결하기 위해 사용됩니다.

---

### 🔷 기본 개념

예를 들어, 일반 인덱스는 다음과 같이 저장됩니다:

| 실제 값 | 인덱스 저장 |
|---------|--------------|
| 100001  | 100001       |
| 100002  | 100002       |
| 100003  | 100003       |

리버스 키 인덱스를 사용하면 값이 뒤집혀서 저장됩니다:

| 실제 값 | 리버스 키 저장 |
|---------|----------------|
| 100001  | 100001 → 100001 (reverse) |
| 100002  | 200001         |
| 100003  | 300001         |

숫자를 문자열로 본 뒤 각 자리를 뒤집는 방식입니다.  
예: 123456 → 654321

---

### 🔷 왜 사용하는가?

**시퀀스 번호, 증가하는 숫자 컬럼 등에 인덱스를 걸면, 삽입 시 항상 마지막 블록에만 접근하게 됩니다.**  
→ 그 블록만 계속 I/O가 발생하고 경합(lock contention)이 생깁니다.  
→ 이를 **"인덱스 핫스팟" 문제**라고 부릅니다.

리버스 키 인덱스는 키를 뒤집어서 저장하므로,  
→ **삽입되는 값이 인덱스 블록에 분산되어**  
→ **경합이 줄고 병렬성이 향상됩니다.**

---

### 🔷 단점

- **범위 검색이 불가능하거나 비효율적**입니다.
  - 예: `WHERE id BETWEEN 100001 AND 100100` → **사용 안 됨**
  - 왜냐하면 뒤집힌 값을 기준으로 정렬되어 있기 때문에, 범위가 의미를 잃음.
- **정렬 성능도 떨어짐** – 인덱스 정렬이 무의미함

---

### 🔷 언제 사용하나?

✅ 대량의 INSERT가 발생하며,  
✅ 인덱스 컬럼 값이 **순차적으로 증가하는 경우**  
→ 예: 시퀀스 기반 ID, 타임스탬프 순서 등  
→ 특히 RAC(Real Application Cluster) 환경에서 효과 큼

---

### 🔷 생성 예시 (Oracle 기준)

```sql
CREATE INDEX idx_emp_id_reverse
ON emp(emp_id)
REVERSE;
```

---

### 🔶 요약

| 항목         | 일반 인덱스 | 리버스 키 인덱스 |
|--------------|-------------|------------------|
| 순차 입력시 | 핫스팟 발생 | 경합 줄어듦      |
| 범위 조건   | 효율적       | 비효율적 or 불가 |
| 정렬        | 정렬 지원   | 정렬 안됨        |
| 삽입 분산   | 안됨         | 잘됨              |
