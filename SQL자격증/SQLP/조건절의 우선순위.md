 인덱스를 구성할 때 **조건절의 우선순위**는 일반적으로 다음과 같은 순서로 성능에 영향을 줍니다:

```
= (동등조건) > BETWEEN (범위조건) > LIKE (접두어 패턴) > 기타 (부등호, 포함조건 등)
```

### 이유 설명:

1. **`=` 조건**

   * 가장 높은 효율을 가짐.
   * 인덱스에서 정확히 일치하는 값을 빠르게 찾을 수 있음 → **Index Seek** 발생 가능.
   * 복합 인덱스에서는 **앞쪽 컬럼이 `=` 조건일 때 다음 컬럼도 인덱스를 탈 가능성이 있음**.

2. **`BETWEEN`, `>`, `<` 같은 범위 조건**

   * 인덱스를 타긴 하지만, 범위가 생기면 그 뒤 인덱스 컬럼은 **사용하지 못함**.
   * 예: `WHERE a = 10 AND b BETWEEN 1 AND 5` → 인덱스는 a, b까지만 활용되고, 그 이후는 무시됨.

3. **`LIKE 'abc%'` (접두사 고정)**

   * 접두사 검색은 인덱스를 탐색할 수 있음.
   * 그러나 `LIKE '%abc'` 같은 **앞이 가변적인 패턴**은 인덱스를 탈 수 없음.

---

### 복합 인덱스 설계 시 주의:

* 복합 인덱스 (예: `CREATE INDEX idx_a_b_c ON table(a, b, c)`):

  * `a = ?` AND `b BETWEEN ? AND ?` → `a, b`까지 인덱스 사용됨.
  * `a = ?` AND `b LIKE 'abc%'` → `a, b`까지 사용 가능.
  * `a BETWEEN ? AND ?` → 그 뒤 `b`, `c`는 **사용 불가**.

---

### 결론:

복합 인덱스를 만들 때는 **조회 조건 중 가장 많이 쓰이는 `=` 조건 컬럼을 앞에 배치하고**, 그 뒤에 `BETWEEN`이나 `LIKE` 조건 컬럼을 두는 것이 성능상 유리합니다.

예를 들어 다음과 같은 조건이 자주 사용된다면:

```sql
WHERE user_id = ? AND create_date BETWEEN ? AND ? AND title LIKE '공지%'
```

이럴 때는 인덱스를 이렇게 설계하는 것이 좋습니다:

```sql
CREATE INDEX idx_user_date_title ON table(user_id, create_date, title)
```

필요하면 실행계획(Explain Plan)으로 확인해볼 수도 있어요. 확인해드릴까요?
