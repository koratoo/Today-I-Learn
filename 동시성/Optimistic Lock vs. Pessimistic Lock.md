# Optimistic Lock vs. Pessimistic Lock: 언제 어떤 것을 선택할까?

데이터베이스를 사용하는 애플리케이션에서는 데이터의 일관성을 유지하기 위해 동시성 제어 메커니즘을 활용합니다. 이때 자주 언급되는 방법이 **Optimistic Lock(낙관적 잠금)** 과 **Pessimistic Lock(비관적 잠금)** 입니다. 두 방식은 각기 다른 철학과 사용 사례를 가지고 있으며, 충돌 발생 빈도에 따라 선택이 달라질 수 있습니다.

## Optimistic Lock (낙관적 잠금)

Optimistic Lock은 이름 그대로 "충돌이 잘 발생하지 않을 것"이라는 낙관적인 가정을 기반으로 설계된 방식입니다. 주로 버전 번호(version number) 또는 타임스탬프(timestamp)를 활용해 데이터의 변경 여부를 검증합니다.

### 동작 원리
1. 데이터를 읽을 때 버전 번호(또는 타임스탬프)를 함께 가져옵니다.
2. 데이터를 수정할 때, 기존에 가져온 버전 번호와 현재 버전 번호를 비교합니다.
3. 버전 번호가 다르면 충돌로 간주하고, 트랜잭션을 롤백하거나 다시 시도합니다.

### 장점
- 잠금을 걸지 않기 때문에 **성능이 우수**합니다.
- Deadlock(교착 상태)이 발생하지 않습니다.
- 읽기 작업이 많은 경우 적합합니다.

### 단점
- **충돌이 빈번히 발생**하는 경우, 재시도 작업이 증가해 성능이 저하될 수 있습니다.
- 충돌이 발생할 때마다 애플리케이션에서 처리 로직이 추가로 필요합니다.

### 사용 사례
- **충돌이 드문** 환경에서 적합합니다.
  - 예: 통계 조회, 사용자 설정 관리 등.

---

## Pessimistic Lock (비관적 잠금)

Pessimistic Lock은 "충돌이 자주 발생할 것"이라는 비관적인 가정을 기반으로 설계된 방식입니다. 데이터에 접근하기 전에 잠금을 걸어 다른 트랜잭션이 데이터를 수정하지 못하게 합니다.

### 동작 원리
1. 데이터를 읽거나 수정하기 전에 잠금을 겁니다.
2. 잠금을 보유한 상태에서 작업을 완료한 후에야 잠금을 해제합니다.

### 장점
- 충돌이 발생할 가능성을 **사전에 차단**합니다.
- 데이터 무결성을 보장하기 쉽습니다.
- 충돌 처리를 애플리케이션이 아닌 데이터베이스 레벨에서 관리할 수 있습니다.

### 단점
- 잠금으로 인해 **성능이 저하**될 수 있습니다.
- Deadlock(교착 상태)의 위험이 존재합니다.
- 읽기 작업이 많은 경우 비효율적입니다.

### 사용 사례
- **충돌이 빈번히 발생**하는 환경에서 적합합니다.
  - 예: 재고 관리, 금융 거래 등.

---

## 결론: 충돌 빈도에 따른 선택 기준

- **충돌이 드물다면?**
  Optimistic Lock이 더 적합합니다. 성능과 리소스 효율성을 극대화할 수 있기 때문입니다.

- **충돌이 빈번하다면?**
  Pessimistic Lock을 사용하는 것이 좋습니다. 데이터 무결성을 보다 강력하게 보장할 수 있기 때문입니다.

---

## 정리
Optimistic Lock과 Pessimistic Lock은 각각의 장단점과 적합한 사용 사례를 가지고 있습니다. 충돌 가능성을 평가하여, 상황에 맞는 방식을 선택하는 것이 중요합니다. 다음과 같은 질문을 스스로에게 던져보세요:

1. 데이터 충돌 가능성이 높은가?
2. 성능과 데이터 무결성 중 무엇이 더 중요한가?

이 질문에 대한 답을 바탕으로 적절한 잠금 방식을 선택한다면, 데이터베이스 성능과 안정성을 모두 잡을 수 있을 것입니다.

